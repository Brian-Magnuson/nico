#include "nico/frontend/utils/symbol_tree.h"

#include <vector>

#include "nico/shared/logger.h"
#include "nico/shared/sets.h"
#include "nico/shared/utils.h"

namespace nico {

void SymbolTree::install_primitive_types() {
    modified = true;
    std::vector<std::shared_ptr<Node::PrimitiveType>> primitive_types = {
        Node::PrimitiveType::create(
            reserved_scope,
            "i8",
            std::make_shared<Type::Int>(true, 8)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "i16",
            std::make_shared<Type::Int>(true, 16)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "i32",
            std::make_shared<Type::Int>(true, 32)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "i64",
            std::make_shared<Type::Int>(true, 64)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "u8",
            std::make_shared<Type::Int>(false, 8)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "u16",
            std::make_shared<Type::Int>(false, 16)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "u32",
            std::make_shared<Type::Int>(false, 32)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "u64",
            std::make_shared<Type::Int>(false, 64)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "f32",
            std::make_shared<Type::Float>(32)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "f64",
            std::make_shared<Type::Float>(64)
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "bool",
            std::make_shared<Type::Bool>()
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "str",
            std::make_shared<Type::Str>()
        ),
        Node::PrimitiveType::create(
            reserved_scope,
            "anyptr",
            std::make_shared<Type::Anyptr>()
        )
    };
    for (auto& ptype : primitive_types) {
        reserved_scope->children[ptype->short_name] = ptype;
        ptype->symbol = reserved_scope->symbol + "::" + ptype->short_name;
        reserved_symbols.insert(ptype->symbol);
    }

    modified = true;
}

bool SymbolTree::resolve_name_from_scope(
    std::shared_ptr<Name> name, std::shared_ptr<Node::IScope> searching_scope
) {
    // If the NameRef has a base...
    if (name->base.has_value()) {
        if (!resolve_name_from_scope(name->base.value(), searching_scope)) {
            // If we could not resolve the base, return false.
            return false;
        }
        // Ensure the base's node is a scope.
        auto base_scope = std::dynamic_pointer_cast<Node::IScope>(
            name->base.value()->node.lock()
        );
        if (!base_scope) {
            // This isn't necesarily an error.
            // It could be we just didn't search high enough.
            return false;
        }
        // Search from the base scope for the identifier.
        auto it =
            base_scope->children.find(std::string(name->identifier->lexeme));
        if (it == base_scope->children.end()) {
            // This isn't necessarily an error.
            // It could be we just didn't search high enough.
            return false;
        }
        name->node = it->second;
        return true;
    }
    // If the NameRef does not have a base...
    else {
        auto it = searching_scope->children.find(
            std::string(name->identifier->lexeme)
        );
        if (it == searching_scope->children.end()) {
            // This isn't necessarily an error.
            // It could be we just didn't search high enough.
            return false;
        }
        name->node = it->second;
        return true;
    }
}

void SymbolTree::reset() {
    root_scope = Node::RootScope::create();
    root_scope->symbol = "";
    current_scope = root_scope;
    reserved_scope = Node::RootScope::create(":");
    reserved_scope->symbol = ":";
    reserved_symbols = {"", ":", "main", "$script"};
    modified = false;

    install_primitive_types();
}

bool SymbolTree::register_symbol(
    std::shared_ptr<Node::ILocatable> node, std::optional<std::string> symbol
) {
    auto is_symbol_autogenerated = !symbol.has_value();
    auto the_symbol =
        symbol.value_or(node->parent.lock()->symbol + "::" + node->short_name);

    if (reserved_symbols.contains(the_symbol)) {
        Logger::inst().log_error(
            Err::SymbolIsReserved,
            node->location,
            "Symbol `" + the_symbol + "` is reserved and cannot be used."
        );
        return false;
    }

    // At this point, the symbol is not reserved.

    auto it = symbol_map.find(the_symbol);
    if (it != symbol_map.end()) {
        if (is_symbol_autogenerated) {
            unsigned long long counter = 1;
            while (symbol_map.contains(the_symbol)) {
                // If the symbol was autogenerated, keep generating new symbols
                // until we find one that is not in use.
                the_symbol = node->parent.lock()->symbol +
                             "::" + node->short_name + "$" +
                             std::to_string(counter++);
            }
            // You would need to generate over 18 quintillion symbols to cause
            // an infinite loop here.
            // Your system would probably run out of memory long before that.

            node->symbol = the_symbol;
            symbol_map[the_symbol] = node->location;
            modified = true;
            return true;
        }

        // If the symbol is already in use by another node...
        Logger::inst().log_error(
            Err::SymbolAlreadyExists,
            node->location,
            "Symbol `" + the_symbol + "` already exists."
        );
        Logger::inst().log_note(
            it->second,
            "Previous declaration of symbol `" + the_symbol + "` found here."
        );

        // Regardless, we cannot register the symbol.
        return false;
    }

    // Register the symbol.
    node->symbol = the_symbol;
    symbol_map[the_symbol] = node->location;
    modified = true;
    return true;
}

std::pair<bool, std::shared_ptr<Node>>
SymbolTree::add_namespace(std::shared_ptr<Token> token) {
    // Namespaces cannot be added in a local scope
    if (PTR_INSTANCEOF(current_scope, Node::LocalScope)) {
        // return std::make_pair(nullptr, Err::NamespaceInLocalScope);
        return {false, nullptr};
    }
    // Namespaces cannot be added in a struct definition
    if (PTR_INSTANCEOF(current_scope, Node::StructDef)) {
        // return std::make_pair(nullptr, Err::NamespaceInStructDef);
        return {false, nullptr};
    }
    // Check if the name is reserved.
    if (auto node = reserved_scope->children.at(std::string(token->lexeme))) {
        // return std::make_pair(node.value(), Err::NameIsReserved);
        return {false, nullptr};
    }

    // Check if the name already exists.
    if (auto node = current_scope->children.at(std::string(token->lexeme))) {
        if (auto ns_node =
                std::dynamic_pointer_cast<Node::Namespace>(node.value())) {
            // If existing name is a namespace...
            current_scope = ns_node;
            modified = true;
            // return std::make_pair(ns_node, Err::Null);
            return {true, ns_node};
        }
        else {
            // If existing name is not a namespace...
            // return std::make_pair(node.value(), Err::NameAlreadyExists);
            return {false, nullptr};
        }
    }
    else {
        // If name does not exist...
        // Add the namespace to its parent scope's children.
        auto new_node = Node::Namespace::create(current_scope, token);
        current_scope->children[new_node->short_name] = new_node;
        modified = true;
        bool ok = register_symbol(new_node);
        if (!ok) {
            return {false, nullptr};
        }

        current_scope = new_node;
        return {true, new_node};
    }
}

std::pair<bool, std::shared_ptr<Node>>
SymbolTree::add_struct_def(std::shared_ptr<Token> token, bool is_class) {
    // Structs cannot be added in a local scope
    if (PTR_INSTANCEOF(current_scope, Node::LocalScope)) {
        return {false, nullptr};
    }
    // Check if the name exists in the reserved scope
    if (auto node = reserved_scope->children.at(std::string(token->lexeme))) {
        return {false, nullptr};
    }

    // Check if the struct already exists in the current scope
    if (auto node = current_scope->children.at(std::string(token->lexeme))) {
        return {false, nullptr};
    }

    auto new_node = Node::StructDef::create(current_scope, token, is_class);
    current_scope->children[new_node->short_name] = new_node;
    modified = true;

    bool ok = register_symbol(new_node);
    if (!ok) {
        return {false, nullptr};
    }

    current_scope = new_node;
    return {true, new_node};
}

std::pair<bool, std::shared_ptr<Node::LocalScope>>
SymbolTree::add_local_scope(std::shared_ptr<Expr::Block> block) {
    auto new_local_scope = Node::LocalScope::create(current_scope, block);
    current_scope->local_scopes.push_back(new_local_scope);
    new_local_scope->symbol =
        current_scope->symbol + "::" + new_local_scope->short_name;

    current_scope = new_local_scope;
    modified = true;
    return {true, new_local_scope};
}

std::optional<std::shared_ptr<Node::IScope>> SymbolTree::exit_scope() {
    if (current_scope->parent.expired()) {
        return std::nullopt; // Cannot exit root scope
    }

    current_scope = current_scope->parent.lock();
    modified = true;
    return current_scope;
}

bool SymbolTree::resolve_name(std::shared_ptr<Name> name) {
    bool found = false;

    // First, search the reserved scope.
    if (resolve_name_from_scope(name, reserved_scope)) {
        found = true;
    }

    // If not found, search from the current scope upward.
    auto searching_scope = current_scope;
    while (!found && searching_scope) {
        if (resolve_name_from_scope(name, searching_scope)) {
            found = true;
        }
        searching_scope = searching_scope->parent.lock();
    }

    if (!found) {
        Logger::inst().log_error(
            Err::NameNotFound,
            name->identifier->location,
            "Could not resolve name `" + name->to_string() + "`."
        );
        return false;
    }

    // If the resolved name is an OverloadGroup with exactly one overload, set
    // the name's node to the single overload instead.
    if (auto overload_group =
            std::dynamic_pointer_cast<Node::OverloadGroup>(name->node.lock())) {
        if (overload_group->overloads.size() == 1) {
            name->node = overload_group->overloads.at(0);
        }
    }
    // This actually isn't needed for the code to compile. But it makes it
    // easier for the user when working with overloadable functions with only
    // one overload.
    // It's also an optimization to avoid checking the overload
    // group later.

    return true;
}

std::optional<std::shared_ptr<Node::LocalScope>>
SymbolTree::get_local_scope_of_kind(Expr::Block::Kind kind) const {
    auto current = current_scope;
    while (current) {
        if (auto local_scope =
                std::dynamic_pointer_cast<Node::LocalScope>(current)) {
            // If this is a local scope, check if it matches the kind.
            if (local_scope->block && local_scope->block->kind == kind) {
                return local_scope;
            }
        }
        else {
            // If this scope is not a local scope, stop searching.
            break;
        }
        current = current->parent.lock();
    }
    return std::nullopt;
}

std::pair<bool, std::shared_ptr<Node>>
SymbolTree::add_field_entry(const Field& field) {
    // Make sure the name is not reserved.
    if (auto node = reserved_scope->children.at(field.name)) {
        Logger::inst().log_error(
            Err::NameIsReserved,
            *field.location,
            "Name `" + std::string(field.name) +
                "` is reserved and cannot be used."
        );
        return {false, nullptr};
    }

    if (auto node = current_scope->children.at(field.name)) {
        Logger::inst().log_error(
            Err::NameAlreadyExists,
            *field.location,
            "Name `" + field.name + "` already exists in the current scope."
        );
        if (auto locatable =
                std::dynamic_pointer_cast<Node::ILocatable>(node.value())) {
            Logger::inst().log_note(
                locatable->location,
                "Previous declaration here."
            );
        }
        return {false, nullptr};
    }

    auto new_node = Node::FieldEntry::create(current_scope, field);
    current_scope->children[new_node->short_name] = new_node;

    bool ok = register_symbol(new_node);
    if (!ok) {
        return {false, nullptr};
    }

    modified = true;

    return {true, new_node};
}

std::pair<bool, std::shared_ptr<Node>>
SymbolTree::add_overloadable_func(const Field& field) {
    // Make sure the name is not reserved.
    if (auto node = reserved_scope->children.at(field.name)) {
        Logger::inst().log_error(
            Err::NameIsReserved,
            *field.location,
            "Name `" + field.name + "` is reserved and cannot be used."
        );
        return {false, nullptr};
    }

    // Check if the name already exists.
    std::shared_ptr<Node::OverloadGroup> overload_group;

    if (auto node = current_scope->children.at(field.name)) {
        if (auto existing_overload_group =
                std::dynamic_pointer_cast<Node::OverloadGroup>(node.value())) {
            // If existing name is an overload group, add to it.
            overload_group = existing_overload_group;
        }
        else {
            // If existing name is not an overload group...
            Logger::inst().log_error(
                Err::NameAlreadyExists,
                *field.location,
                "Name `" + field.name +
                    "` already exists in the current scope and is not an "
                    "overloadable function."
            );
            if (auto locatable =
                    std::dynamic_pointer_cast<Node::ILocatable>(node.value())) {
                Logger::inst().log_note(
                    locatable->location,
                    "Previous declaration here."
                );
            }
            return {false, nullptr};
        }
    }
    else {
        // If name does not exist, create a new overload group.
        overload_group = Node::OverloadGroup::create(
            current_scope,
            field.name,
            field.location
        );
        current_scope->children[overload_group->short_name] = overload_group;
        modified = true;

        bool ok = register_symbol(overload_group);
        if (!ok) {
            return {false, nullptr};
        }
    }

    auto func_type = std::dynamic_pointer_cast<Type::Function>(field.type);
    if (!func_type)
        panic("Field added as overloadable function is not a function.");
    auto [m_f1, d_f1] = func_type->get_param_sets();

    // Check for overload conflicts.
    std::vector<std::shared_ptr<Node::FieldEntry>> conflicts;
    for (const auto& existing_overload : overload_group->overloads) {
        auto existing_func_type = std::dynamic_pointer_cast<Type::Function>(
            existing_overload->field.type
        );
        if (!existing_func_type)
            panic("Existing overload in overload group is not a function.");
        auto [m_f2, d_f2] = existing_func_type->get_param_sets();
        auto conflict_found =
            sets::equals(m_f1, m_f2) ||
            (sets::subset(m_f2, m_f1) &&
             sets::subseteq(sets::difference(m_f1, m_f2), d_f1)) ||
            (sets::subset(m_f1, m_f2) &&
             sets::subseteq(sets::difference(m_f2, m_f1), d_f2));

        if (conflict_found) {
            conflicts.push_back(existing_overload);
        }
    }
    if (!conflicts.empty()) {
        Logger::inst().log_error(
            Err::FunctionOverloadConflict,
            *field.location,
            "Function overload conflict for function `" + field.name + "`."
        );
        for (const auto& conflict : conflicts) {
            if (auto locatable =
                    std::dynamic_pointer_cast<Node::ILocatable>(conflict)) {
                Logger::inst().log_note(
                    locatable->location,
                    "Conflicting overload declared here."
                );
            }
            Logger::inst().log_note(
                "Two function overloads conflict if they have the same "
                "set of parameters, or if one set of parameters is a "
                "superset of the other, differing only by optional "
                "parameters."
            );
        }
        return {false, nullptr};
    }

    auto new_node = Node::FieldEntry::create(current_scope, field);
    auto custom_symbol = overload_group->symbol + "$" +
                         std::to_string(overload_group->overloads.size() + 1);
    bool ok = register_symbol(new_node, custom_symbol);
    if (!ok) {
        return {false, nullptr};
    }
    overload_group->overloads.push_back(new_node);
    modified = true;

    return {true, new_node};
}

std::string SymbolTree::to_tree_string() const {
    std::string result;
    result += "RESERVED SCOPE:\n";
    result += reserved_scope->to_tree_string(2);
    result += "\nMAIN TREE:\n";
    result += root_scope->to_tree_string(2);
    return result;
}

} // namespace nico
