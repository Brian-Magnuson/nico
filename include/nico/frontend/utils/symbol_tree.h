#ifndef NICO_SYMBOL_TREE_H
#define NICO_SYMBOL_TREE_H

#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#include "nico/frontend/utils/ast_node.h"
#include "nico/frontend/utils/symbol_node.h"
#include "nico/frontend/utils/type_node.h"
#include "nico/shared/dictionary.h"
#include "nico/shared/error_code.h"

namespace nico {

/**
 * @brief A symbol tree that represents the structure of the program's symbols.
 *
 * All scopes/declarations are stored in this tree, which is used to resolve
 * identifiers and types.
 *
 * The tree structure enables identifiers with multiple parts to be resolved by
 * searching upward and downward through different scopes.
 */
class SymbolTree {
    // Whether or not the symbol tree has been modified since this flag was
    // cleared or the tree was created/reset.
    bool modified = false;

    /**
     * @brief Installs primitive types into the root scope of the symbol tree.
     */
    void install_primitive_types();

    /**
     * @brief Helper function to search a name, starting from a specific
     * location.
     *
     * The search algorithm comes in two parts: upward search and downward
     * search.
     *
     * Upward search: Search from the current scope upward until the first part
     * of the Name matches. Downward search: Search from the matched scope
     * downward for the remaining parts of the Name. If downward search fails,
     * resume upward search until the next match is found or the root scope is
     * reached.
     *
     * @param name The name to search for.
     * @param scope The scope to start the search from.
     * @return std::optional<std::shared_ptr<Node>> The node if found, or
     * std::nullopt if not found.
     */
    std::optional<std::shared_ptr<Node>> search_name_from_scope(
        const Name& name, std::shared_ptr<Node::IScope> scope
    ) const;

public:
    // The root scope of the symbol tree, which is the top-level scope that
    // contains all other scopes.
    std::shared_ptr<Node::RootScope> root_scope;
    // A special scope for reserved names. Reserved names cannot be shadowed in
    // any scope. This scope is searched first, regardless of what scope is
    // currently active.
    std::shared_ptr<Node::RootScope> reserved_scope;

    // A map of user-defined symbols to their corresponding locations.
    std::unordered_map<std::string, const Location*> symbol_map;
    // A set of reserved symbols that cannot be used by user-defined nodes.
    std::unordered_set<std::string> reserved_symbols;

    // The current scope in the symbol tree, which is the scope that is
    // currently being modified or accessed.
    std::shared_ptr<Node::IScope> current_scope;

    /**
     * @brief Constructs a symbol tree with a root scope and installs primitive
     * types.
     */
    SymbolTree() { reset(); }

    /**
     * @brief Resets the symbol tree to its initial state.
     *
     * This function will reset the root scope to a new instance of
     * Node::RootScope and set the current scope to the root scope. It also
     * installs primitive types into the root scope.
     *
     * This function should be called before starting a new type-checking pass
     * or when reinitializing the symbol tree.
     */
    void reset();

    /**
     * @brief Checks if the symbol tree has been modified since the last
     * reset or since this flag was last cleared.
     *
     * @return True if the symbol tree has been modified, false otherwise.
     */
    bool was_modified() const { return modified; }

    /**
     * @brief Clears the modified flag, indicating that the symbol tree is
     * considered unmodified.
     */
    void clear_modified() { modified = false; }

    /**
     * @brief Registers a node's symbol in the symbol tree.
     *
     * The symbol and the node will be added to the symbol map.
     * If the symbol already exists the function will log an error and return
     * false.
     *
     * If no symbol is provided, one will be created based on the node's
     * position within the tree.
     * The autogenerated symbol is guaranteed to be unique. It may contain a
     * suffix with a number to ensure uniqueness.
     *
     * @param node The node whose symbol is to be registered.
     * @param symbol An optional symbol to register. If not provided, a symbol
    will be generated.
     * @return
    j */
    bool register_symbol(
        std::shared_ptr<Node::ILocatable> node,
        std::optional<std::string> symbol = std::nullopt
    );

    /**
     * @brief Enters the namespace with the name contained in token, adding it
     * if it does not exist.
     *
     * If the current scope does not allow namespaces, this function does not
     * add the namespace and returns a pair with false and nullptr.
     *
     * If the namespace already exists, the namespace will not be added, and the
     * existing namespace will be entered.
     * The function will return a pair with true and the existing namespace
     * node.
     *
     * If the name already exists in the current scope and does not correspond
     * to a namespace, this function does not add the namespace and returns a
     * pair with false and nullptr.
     *
     * @param name The name of the namespace.
     * @return std::pair<bool, std::shared_ptr<Node>> The result of adding the
     * namespace (see description).
     */
    std::pair<bool, std::shared_ptr<Node>>
    add_namespace(std::shared_ptr<Token> token);

    /**
     * @brief Adds a struct definition to the symbol tree, then enters the
     * struct definition scope.
     *
     * If the struct definition already exists, or the current scope does not
     * allow structs, this function does not add the struct and returns a pair
     * with false and nullptr.
     *
     * @param name The name of the struct.
     * @return std::pair<bool, std::shared_ptr<Node>> The struct definition if
     * added successfully (first), or false and nullptr (second).
     */
    std::pair<bool, std::shared_ptr<Node>>
    add_struct_def(std::shared_ptr<Token> token, bool is_class = false);

    /**
     * @brief Adds a new local scope to the symbol tree, then enters the local
     * scope.
     *
     * Currently, this function has no restrictions on where local scopes can be
     * added.
     *
     * @param block The block expression representing the local scope.
     * @return std::pair<bool, std::shared_ptr<Node::LocalScope>> The local
     * scope if added successfully (first), or false and nullptr (second).
     */
    std::pair<bool, std::shared_ptr<Node::LocalScope>>
    add_local_scope(std::shared_ptr<Expr::Block> block);

    /**
     * @brief Exits the current scope and returns to the parent scope.
     *
     * If the current scope is the root scope, this function does nothing and
     * returns std::nullopt.
     *
     * If the current scope is a local scope, its set of declared variables is
     * cleared upon exit.
     *
     * @return std::optional<std::shared_ptr<Node::IScope>> The parent scope if
     * it exists, or std::nullopt if there is no parent scope (i.e., if the
     * current scope is the root scope).
     */
    std::optional<std::shared_ptr<Node::IScope>> exit_scope();

    /**
     * @brief Searches the symbol tree for a node with the matching name.
     *
     * First, the search is performed starting from the reserved scope.
     * Then, if the node wasn't found, the search is performed starting from the
     * current scope.
     *
     * Note: If the desired node is a FieldEntry, this function does not reveal
     * whether the field entry is currently declared. Consider adding a check in
     * the type checker.
     *
     * @param name The name to search for.
     * @return std::optional<std::shared_ptr<Node>> The node if found, or
     * std::nullopt if not found.
     */
    std::optional<std::shared_ptr<Node>> search_name(const Name& name) const;

    /**
     * @brief Retrieves the nearest local scope of the specified kind, starting
     * from the current scope and searching upward.
     *
     * This function is useful for determining if the current scope is within a
     * loop or function.
     *
     * @param kind The kind of scope to search for.
     * @return The nearest local scope of the specified kind, or std::nullopt if
     * none is found or if the current scope is not a local scope.
     */
    std::optional<std::shared_ptr<Node::LocalScope>>
    get_local_scope_of_kind(Expr::Block::Kind kind) const;

    /**
     * @brief Adds a field entry to the symbol tree in the current scope.
     *
     * This function is for variables, properties, and non-overloadable
     * functions. For overloadable functions, use add_overloadable_func instead.
     *
     * If the field name already exists in the current scope, this function does
     * not add the field and returns false and nullptr.
     *
     * Because a field entry carries a type object, the field's type must be
     * resolved before being added to the symbol tree.
     *
     * @param field The field to add.
     * @return std::pair<bool, std::shared_ptr<Node>> The field entry if added
     * successfully, or false and nullptr (second).
     */
    std::pair<bool, std::shared_ptr<Node>> add_field_entry(const Field& field);

    /**
     * @brief Adds an overloadable function to the symbol tree in the current
     * scope.
     *
     * This function is for overloadable functions. For other field entries, use
     * add_field_entry instead.
     *
     * If the function name does not exist, a new overload group will be created
     * and the function will be added to it.
     *
     * If the function name already exists, but does not refer to an overload
     * group, this function does not add the function and returns false and
     * nullptr.
     *
     * If the function overload group is found, but the new function conflicts
     * with an existing function, the function is not added and returns false
     * and nullptr.
     *
     * @param field The field to add.
     * @return std::pair<bool, std::shared_ptr<Node>> The field entry if added
     * successfully, or false and nullptr (second).
     */
    std::pair<bool, std::shared_ptr<Node>>
    add_overloadable_func(const Field& field);

    /**
     * @brief Returns a string representation of the symbol tree.
     *
     * The string representation uses indentation to represent the tree
     * structure.
     *
     * @return std::string A string representation of the symbol tree.
     */
    std::string to_tree_string() const;
};

} // namespace nico

#endif // NICO_SYMBOL_TREE_H
